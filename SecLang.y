
class SecLang

rule

	commands: /* empty */ { result = false }
           | LPAREN commands RPAREN ANDTOK commands
           {
             result = val[1] && val[4]
           }
           | LPAREN commands RPAREN ORTOK commands
           {
             result = val[1] || val[4]
           }
           | truth_stmt SEMICOLON commands
           | truth_stmt ANDTOK commands
           {
             result = val[0] && val[2]
           }
           | truth_stmt ORTOK commands
           {
             result = val[0] || val[2]
           }
           |
           truth_stmt EQ commands
           {
             result = val[0] == val[2]
           }
           |
           truth_stmt GT commands
           {
             result = val[0] > val[2]
           }
           |
           truth_stmt LT commands
           {
             result = val[0] < val[2]
           }
           |
           truth_stmt LE commands
           {
             result = val[0] <= val[2]
           }
           |
           truth_stmt GE commands
           {
             result = val[0] >= val[2]
           }
           |
           truth_stmt NE commands
           {
             result = val[0] != val[2]
           }
           | truth_stmt
           ;

truth_stmt:
           command
           |
           not_command
           |
           VAR
           {
		result = var_value(val[0])
           }
           ;

not_command:
           NOTTOK command
           {
                  result = val[1] ? false : true
           }
           ;

command:
           puts_cmd
           |
           print_cmd
           |
           type_cmd
           |
           get_mode_cmd
           |
           set_mode_cmd
           |
           vardec_cmd
           |
           varinc_cmd
           |
           variable_assignment
           ;

puts_cmd:
          PUTSTOK command
          {
		result = puts(val[1])
          }
          |
          PUTSTOK quotedtext
          {
 		result = puts(val[1])
          }
          |
          PUTSTOK DIGITS
          {
		result = puts(val[1])
          }
          |
          PUTSTOK VAR
          {
		result = puts(var_value(val[1]))
          }
          |
          PUTSTOK LPAREN commands RPAREN
          {
		result = puts(val[2])
          }
          ;

print_cmd:
          PRINTTOK command
          {
		result = print(val[1])
          }
          | 
          PRINTTOK quotedtext
          {
		result = print(val[1])
	  }
          |
          PRINTTOK DIGITS
          {
		result = print(val[1])
          }
          PRINTTOK VAR
          {
		result = print(var_value(val[1]))
          }
	  ;

type_cmd:
          TYPETOK LPAREN VAR RPAREN
          {
		result = var_type(val[2])
          }
          ;

set_mode_cmd:
          SETMODETOK LPAREN VAR COMMA SYMBOL RPAREN
          {
		result = var_set_mode(val[2], val[4])
          }
          ;

get_mode_cmd:
          GETMODETOK LPAREN VAR RPAREN
          {
		result = var_get_mode(val[2])
          }
          ;

vardec_cmd:
          VARDECTOK
          {
		result = var_dec(val[0])
          }
          |
          VAR VARDECAMT DIGITS
          {
		result = var_dec(val[0], val[2])
          }
          |
          VAR VARDECAMT VAR
          {
             	result = var_dec_var(val[0], val[2])
          }
          ;

varinc_cmd:
          VARINCTOK
          {
		result = var_inc(val[0])
          }
          |
          VAR VARINCAMT DIGITS
          {
		result = var_inc(val[0], val[2])
          }
          |
          VAR VARINCAMT VAR
          {
             	result = var_inc_var(val[0], val[2])
          }
          ;

variable_assignment:
          VAR EQUAL command
          {
                r = val[2]
                if r.is_a? SecVar
                  result = add_var(val[0], r)
                elsif r.is_a? Integer
		  result = add_var(val[0], IntVar.new(val[2]))
                else r.is_a? String
		  result = add_var(val[0], StringVar.new(val[2]))
                end
		result
          }
          |
          VAR EQUAL VAR
          {
		result = copy_var(val[0], val[2])
          }
          |
          VAR EQUAL DIGITS
          {
		result = add_var(val[0], IntVar.new(val[2]))
          }
          |
          VAR EQUAL quotedtext
          {
		result = add_var(val[0], StringVar.new(val[2]))
          }
          |
          VAR EQUAL IPV4ADDR
          {
		result = add_var(val[0], IPv4Var.new(val[2]))
          }
          |
          VAR EQUAL LPAREN commands RPAREN
          {
                t = val[3]
		result = add_var(val[0], StringVar.new(t.to_s))
          }
          ;

quotedtext:
         QUOTE DATA QUOTE
         {
		result = val[1]
         }
         | SINGLE_QUOTE DATA SINGLE_QUOTE
         {
		result = val[1]
         }
         ;

end

---- header ----

# generated by racc

require 'strscan'
require "./SecVar"

---- inner ----    
  def initialize
    @syntax_check = false
    @var = {}
  end

  def check_syntax( str )
    @syntax_check = true
    res = parse(str)
    @syntax_check = false
    return res
  end

  def parse(str)
    @script = str
    state = :MAIN
    tokens = []
    last_state = []
    last_state.push state
    scanner = StringScanner.new(str)
    
    until scanner.eos?
      case
        when state == :MAIN
          case
            when m = scanner.scan(/puts/)
              tokens.push [:PUTSTOK, m]
            when m = scanner.scan(/print/)
              tokens.push [:PRINTTOK, m]
            when m = scanner.scan(/type/)
              tokens.push [:TYPETOK, m]
            when m = scanner.scan(/mode/)
              tokens.push [:GETMODETOK, m]
            when m = scanner.scan(/set_mode/)
              tokens.push [:SETMODETOK, m]
            when m = scanner.scan(/\(/)
              tokens.push [:LPAREN, m]
            when m = scanner.scan(/\)/)
              tokens.push [:RPAREN, m]
            when m = scanner.scan(/\"/)
              tokens.push [:QUOTE, m]
              last_state.push state
              state = :QUOTED 
            when m = scanner.scan(/\'/)
              tokens.push [:SINGLE_QUOTE, m]
              last_state.push state
              state = :SINGLE_QUOTED
            when m = scanner.scan(/,/)
              tokens.push [:COMMA, m]
            when m = scanner.scan(/==/)
              tokens.push [:EQ, m]
            when m = scanner.scan(/</)
              tokens.push [:LT, m]
            when m = scanner.scan(/>/)
              tokens.push [:GT, m]
            when m = scanner.scan(/>=/)
              tokens.push [:GE, m]
            when m = scanner.scan(/<=/)
              tokens.push [:LE, m]
            when m = scanner.scan(/!=/)
              tokens.push [:NE, m]
            when m = scanner.scan(/\|\|/)
              tokens.push [:ORTOK, m]
            when m = scanner.scan(/&&/)
              tokens.push [:ANDTOK, m]
            when m = scanner.scan(/=/)
              tokens.push [:EQUAL, m]
            when m = scanner.scan(/(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/)
              tokens.push [:IPV4ADDR, m]
            when m = scanner.scan(/\+=/)
              tokens.push [:VARINCAMT, m]
            when m = scanner.scan(/-=/)
              tokens.push [:VARDECAMT, m]
            when m = scanner.scan(/:[a-zA-Z][a-zA-Z0-9_-]*/)
              tokens.push [:SYMBOL, m]
            when m = scanner.scan(/[a-zA-Z][a-zA-Z0-9_]*\-\-/)
              tokens.push [:VARDECTOK, m ]
            when m = scanner.scan(/[a-zA-Z][a-zA-Z0-9_]*\+\+/)
              tokens.push [:VARINCTOK, m ]
            when m = scanner.scan(/[a-zA-Z][a-zA-Z0-9_]*/)
              tokens.push [:VAR, m]
            when m = scanner.scan(/\d+/)
              tokens.push [:DIGITS, m]
            when m = scanner.scan(/;/)
              tokens.push [:SEMICOLON, m]
            when scanner.scan(/[ \t\r\n]/)
              # ignore whtiespace
            else
              puts "Syntax error around #{scanner.pos} #{scanner.rest}"
              return -1
          end
       when state == :QUOTED
         case
           when m = scanner.scan(/\"/)
             tokens.push [:QUOTE, m]
             state = last_state.pop
           when m = scanner.scan(/[^"]+/)
             tokens.push [:DATA, m]
           when m = scanner.scan(/[ \t\r\n]/)
             # ignore whitespace
         end
       when state == :SINGLE_QUOTED
         case
           when m = scanner.scan(/\'/)
             tokens.push [:SINGLE_QUOTE, m]
             state = last_state.pop
           when m = scanner.scan(/[^']+/)
             tokens.push [:DATA, m]
           when m = scanner.scan(/[ \t\r\n]/)
             # ignore whitespace
         end

       end
    end
    tokens.push [false, false]

    if last_state.size > 1 then
      puts "Unclosed brackets (#{last_state.pop.to_s})"
      return -1
    end

    truth = yyparse(tokens, :each)
  end

  def on_error(error_token_id, error_value, value_stack)
    msg = "parse error "
    msg << "after #{value_stack.last} " if value_stack.length > 1
    msg << "on #{token_to_str(error_token_id)} #{error_value}"
    raise ParseError, msg
  end

  def add_var(name, var)
    @var[name] = var
  end

  def copy_var(dst_name, src_name)
    if not @var.has_key? src_name
      raise ParseError, "#{src_name} not defined"
    else
      @var[dst_name] = @var[src_name].dup
    end
  end

  def var_value(name)
    if @var.has_key? name
      @var[name].value
    else
     raise ParseError, "#{name} not assigned"
    end
  end

  def var_type(name)
    @var[name].type.to_s
  end

  def var_dec(name, amt=1)
    name = name.gsub(/\-\-$/, "")
    if @var.has_key? name then
      @var[name].dec(amt.to_i)
    else
      raise ParseError, "#{name} not assigned"
    end
    @var[name].value
  end

  def var_inc(name, amt=1)
    name = name.gsub(/\+\+$/, "")
    if @var.has_key? name then
      @var[name].inc(amt.to_i)
    else
      raise ParseError, "#{name} not assigned"
    end
    @var[name].value
  end

  def var_inc_var(dst_name, src_name)
    if not @var.has_key? src_name then
      raise ParseError, "#{src_name} not defined"
    end
    if var_type(src_name) != "integer" then
      raise ParseError, "Can not add #{src_name} of type #{var_type(src_name)}"
    end
    var_inc(dst_name, var_value(src_name))
  end

  def var_dec_var(dst_name, src_name)
    if not @var.has_key? src_name then
      raise ParseError, "#{src_name} not defined"
    end
    if var_type(src_name) != "integer" then
      raise ParseError, "Can not add #{src_name} of type #{var_type(src_name)}"
    end
    var_dec(dst_name, var_value(src_name))
  end

  def var_get_mode(name)
    if not @var.has_key? name then
      raise ParseError, "#{name} not assigned"
    end
    @var[name].mode
  end

  def var_set_mode(name, mode)
    if @var.has_key? name then
      @var[name].set_mode mode
    else
      raise ParseError, "#{name} not assigned"
    end
    @var[name].mode
  end

  def is_eq?(val1, val2)
    val1 = val2
  end

---- footer ----

